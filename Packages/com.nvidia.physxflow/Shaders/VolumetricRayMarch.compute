// High-performance GPU volumetric ray marching compute shader
// Renders 3D fluid density with lighting and shadows
#pragma kernel CSMain

// Input textures
Texture3D<float> _DensityTexture;
Texture3D<float4> _VelocityTexture;
SamplerState sampler_DensityTexture;

// Output
RWTexture2D<float4> _Result;

// Camera parameters
float4x4 _InvViewProj;
float3 _CameraPos;
float3 _CameraForward;

// Volume parameters
float3 _VolumePosition;
float3 _VolumeSize;
float _CellSize;

// Rendering parameters
float _DensityScale;
float4 _Color;
float _StepSize;
int _MaxSteps;
float _LightIntensity;
float3 _LightDir;

// Ray-AABB intersection
bool IntersectAABB(float3 rayOrigin, float3 rayDir, float3 boxMin, float3 boxMax, out float tMin, out float tMax)
{
    float3 invDir = 1.0 / rayDir;
    float3 t0 = (boxMin - rayOrigin) * invDir;
    float3 t1 = (boxMax - rayOrigin) * invDir;
    
    float3 tmin = min(t0, t1);
    float3 tmax = max(t0, t1);
    
    tMin = max(max(tmin.x, tmin.y), tmin.z);
    tMax = min(min(tmax.x, tmax.y), tmax.z);
    
    return tMax >= tMin && tMax > 0.0;
}

// Sample density with trilinear filtering
float SampleDensity(float3 uvw)
{
    // Clamp to valid range
    uvw = saturate(uvw);
    return _DensityTexture.SampleLevel(sampler_DensityTexture, uvw, 0);
}

// Calculate lighting (simple directional + ambient)
float CalculateLighting(float3 worldPos, float3 normal)
{
    float diffuse = max(dot(normal, -_LightDir), 0.0) * _LightIntensity;
    float ambient = 0.2;
    return ambient + diffuse;
}

// Estimate normal from density gradient
float3 EstimateNormal(float3 uvw, float3 texelSize)
{
    float dx = SampleDensity(uvw + float3(texelSize.x, 0, 0)) - SampleDensity(uvw - float3(texelSize.x, 0, 0));
    float dy = SampleDensity(uvw + float3(0, texelSize.y, 0)) - SampleDensity(uvw - float3(0, texelSize.y, 0));
    float dz = SampleDensity(uvw + float3(0, 0, texelSize.z)) - SampleDensity(uvw - float3(0, 0, texelSize.z));
    
    float3 normal = float3(dx, dy, dz);
    return normalize(normal + float3(0.001, 0.001, 0.001)); // Avoid zero
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    _Result.GetDimensions(width, height);
    
    if (id.x >= width || id.y >= height)
        return;
    
    // Calculate ray from camera through pixel
    float2 uv = (id.xy + 0.5) / float2(width, height);
    float2 ndc = uv * 2.0 - 1.0;
    
    // Reconstruct world position
    float4 nearPoint = mul(_InvViewProj, float4(ndc.x, ndc.y, 0.0, 1.0));
    float4 farPoint = mul(_InvViewProj, float4(ndc.x, ndc.y, 1.0, 1.0));
    nearPoint /= nearPoint.w;
    farPoint /= farPoint.w;
    
    float3 rayOrigin = _CameraPos;
    float3 rayDir = normalize(farPoint.xyz - nearPoint.xyz);
    
    // Volume bounds
    float3 boxMin = _VolumePosition - _VolumeSize * 0.5;
    float3 boxMax = _VolumePosition + _VolumeSize * 0.5;
    
    // Intersect ray with volume
    float tMin, tMax;
    if (!IntersectAABB(rayOrigin, rayDir, boxMin, boxMax, tMin, tMax))
    {
        _Result[id.xy] = float4(0, 0, 0, 0);
        return;
    }
    
    // Ensure we start inside or at the box
    tMin = max(tMin, 0.0);
    
    // Ray marching
    float t = tMin;
    float stepSize = _StepSize;
    float accumDensity = 0.0;
    float3 accumColor = float3(0, 0, 0);
    float transmittance = 1.0;
    
    float3 texelSize = 1.0 / _VolumeSize;
    
    int steps = 0;
    while (t < tMax && transmittance > 0.01 && steps < _MaxSteps)
    {
        float3 worldPos = rayOrigin + rayDir * t;
        
        // Convert world position to UVW coordinates
        float3 uvw = (worldPos - boxMin) / (boxMax - boxMin);
        
        // Sample density
        float density = SampleDensity(uvw) * _DensityScale;
        
        if (density > 0.01)
        {
            // Estimate normal for lighting
            float3 normal = EstimateNormal(uvw, texelSize);
            float lighting = CalculateLighting(worldPos, normal);
            
            // Accumulate color and opacity
            float opacity = 1.0 - exp(-density * stepSize);
            float3 sampleColor = _Color.rgb * lighting * opacity * transmittance;
            
            accumColor += sampleColor;
            transmittance *= (1.0 - opacity);
        }
        
        t += stepSize;
        steps++;
    }
    
    // Output final color
    float alpha = 1.0 - transmittance;
    _Result[id.xy] = float4(accumColor, alpha);
}
